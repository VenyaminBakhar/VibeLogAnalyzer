package com.loganalyzer.service;

import com.loganalyzer.dto.QueryResponse;
import com.loganalyzer.model.AppSetting;
import com.loganalyzer.model.LogEntry;
import com.loganalyzer.model.LogPattern;
import com.loganalyzer.repository.AppSettingRepository;
import com.loganalyzer.repository.LogEntryRepository;
import com.loganalyzer.repository.LogPatternRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import jakarta.persistence.EntityManager;
import jakarta.persistence.Query;
import java.math.BigInteger;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@Service
public class LogAnalyzerService {

    private static final Logger logger = LoggerFactory.getLogger(LogAnalyzerService.class);
    private static final String DEEPSEEK_API_KEY = "deepseek_api_key";

    @Autowired
    private LogPatternRepository logPatternRepository;

    @Autowired
    private LogEntryRepository logEntryRepository;

    @Autowired
    private AppSettingRepository appSettingRepository;

    @Autowired
    private DeepSeekService deepSeekService;

    @Autowired
    private EntityManager entityManager;

    // Two-step log analysis process
    public QueryResponse processQuery(String userQuery) {
        try {
            // Get API key
            String apiKey = getDeepSeekApiKey();
            
            // Get log patterns
            List<LogPattern> patterns = logPatternRepository.findAll();
            
            // Step 1: Generate SQL query using DeepSeek
            logger.info("Step 1: Generating SQL query for user request: {}", userQuery);
            String sqlQuery = deepSeekService.generateSqlQuery(userQuery, patterns, apiKey);
            logger.info("Generated SQL: {}", sqlQuery);
            
            // Step 1.5: Execute the generated SQL query against log_entries table
            List<LogEntry> relevantLogs = executeLogQuery(sqlQuery);
            logger.info("Found {} relevant logs using generated SQL", relevantLogs.size());
            
            // Step 2: Analyze the logs using DeepSeek
            logger.info("Step 2: Analyzing logs with DeepSeek");
            String analysis = deepSeekService.analyzeLogs(userQuery, relevantLogs, apiKey);
            
            return new QueryResponse(analysis, relevantLogs);
            
        } catch (Exception e) {
            logger.error("Error processing query", e);
            throw new RuntimeException("Failed to process query: " + e.getMessage());
        }
    }

    // Log Patterns CRUD
    public List<LogPattern> getAllLogPatterns() {
        return logPatternRepository.findAll();
    }

    public LogPattern saveLogPattern(LogPattern pattern) {
        return logPatternRepository.save(pattern);
    }

    public void deleteLogPattern(Long id) {
        logPatternRepository.deleteById(id);
    }

    // API Key management
    public String getDeepSeekApiKey() {
        Optional<AppSetting> setting = appSettingRepository.findBySettingKey(DEEPSEEK_API_KEY);
        if (setting.isEmpty()) {
            throw new RuntimeException("DeepSeek API key not configured. Please set it in Settings.");
        }
        return setting.get().getSettingValue();
    }

    public String getMaskedApiKey() {
        try {
            String apiKey = getDeepSeekApiKey();
            if (apiKey.length() > 8) {
                return apiKey.substring(0, 4) + "****" + apiKey.substring(apiKey.length() - 4);
            }
            return "****";
        } catch (Exception e) {
            return "Not configured";
        }
    }

    public void saveDeepSeekApiKey(String apiKey) {
        // Check if setting already exists
        Optional<AppSetting> existingSetting = appSettingRepository.findBySettingKey(DEEPSEEK_API_KEY);
        if (existingSetting.isPresent()) {
            AppSetting setting = existingSetting.get();
            setting.setSettingValue(apiKey);
            appSettingRepository.save(setting);
        } else {
            AppSetting setting = new AppSetting(null, DEEPSEEK_API_KEY, apiKey);
            appSettingRepository.save(setting);
        }
    }


    // Log Entries CRUD
    public List<LogEntry> getAllLogEntries() {
        return logEntryRepository.findAllByOrderByTimestampDesc();
    }

    public LogEntry saveLogEntry(LogEntry logEntry) {
        if (logEntry.getTimestamp() == null) {
            logEntry.setTimestamp(java.time.LocalDateTime.now());
        }
        return logEntryRepository.save(logEntry);
    }

    public void deleteLogEntry(Long id) {
        logEntryRepository.deleteById(id);
    }

    /**
     * Execute the SQL query generated by DeepSeek against the log_entries table
     */
    private List<LogEntry> executeLogQuery(String sqlQuery) {
        try {
            // Clean up the SQL query - remove any markdown formatting
            String cleanSql = sqlQuery.trim();
            if (cleanSql.startsWith("```sql")) {
                cleanSql = cleanSql.substring(6);
            }
            if (cleanSql.endsWith("```")) {
                cleanSql = cleanSql.substring(0, cleanSql.length() - 3);
            }
            cleanSql = cleanSql.trim();
            
            logger.info("Executing SQL query: {}", cleanSql);
            
            // Execute native SQL query
            Query nativeQuery = entityManager.createNativeQuery(cleanSql);
            List<Object[]> results = nativeQuery.getResultList();
            
            // Convert results to LogEntry objects
            List<LogEntry> logEntries = new ArrayList<>();
            for (Object[] row : results) {
                LogEntry entry = new LogEntry();
                
                // Map database columns to LogEntry fields
                // Assuming query returns: id, log_level, message, timestamp
                if (row.length >= 4) {
                    entry.setId(((BigInteger) row[0]).longValue());
                    entry.setLogLevel((String) row[1]);
                    entry.setMessage((String) row[2]);
                    
                    // Handle timestamp conversion
                    if (row[3] instanceof Timestamp) {
                        entry.setTimestamp(((Timestamp) row[3]).toLocalDateTime());
                    } else if (row[3] instanceof LocalDateTime) {
                        entry.setTimestamp((LocalDateTime) row[3]);
                    }
                }
                
                logEntries.add(entry);
            }
            
            return logEntries;
            
        } catch (Exception e) {
            logger.error("Error executing SQL query: {}", sqlQuery, e);
            
            // Fallback: return recent logs if SQL execution fails
            logger.warn("Falling back to recent logs due to SQL execution error");
            List<LogEntry> fallbackLogs = logEntryRepository.findAllByOrderByTimestampDesc();
            return fallbackLogs.size() > 50 ? fallbackLogs.subList(0, 50) : fallbackLogs;
        }
    }
}